<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[递归练习]]></title>
      <url>http://yoursite.com/2015/10/11/%E9%80%92%E5%BD%92%E7%BB%83%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="对于递归"><a href="#对于递归" class="headerlink" title="对于递归"></a>对于递归</h2><p>这几道题目难度都不大，甚至有些不用递归会有更简洁的方式实现。但强制自己用递归实现出来，对于学习这种解决问题的方法还是有帮助的。<br>对于判断出能用递归解决的问题，可以先把“归”确定下来，然后再想如何“递”，并把“递”的各种情况考虑清楚、完善，整道题目应该就解决得差不多了。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="cube-vals-rec"><a href="#cube-vals-rec" class="headerlink" title="cube_vals_rec()"></a>cube_vals_rec()</h3><h4 id="question"><a href="#question" class="headerlink" title="question:"></a>question:</h4><p>wrire a function cube_vals_rec(values) that takes as input a list of numbers called values, and that uses recursion to create and return a list containing the cubes of the numbers in values. For example:</p>
<pre><code>cube_vals_rec([-2,5,4,-3])   # return [-8,125,64,-27]
</code></pre><h4 id="resolution"><a href="#resolution" class="headerlink" title="resolution:"></a>resolution:</h4><pre><code># python 3.5
def cube_vals_rec(values):
if(len(values)==0):
    return []
else :
    return [values[0]**3]+(cube_vals_rec(values[1:]))

if __name__==&quot;__main__&quot;:
    print(cube_vals_rec([-2,5,4,-3]))
</code></pre><h3 id="num-greater"><a href="#num-greater" class="headerlink" title="num_greater()"></a>num_greater()</h3><h4 id="question-1"><a href="#question-1" class="headerlink" title="question:"></a>question:</h4><p>3)write a function called num_greater(threshold, values) that takes as inputs a number threshold and a list of numbers values, and that returns the number of elements of values that are greater than threshold that threshold. For example:</p>
<pre><code>num_greater(5,[1,7,3,5,10])     # return    2
num_greater(10,[1,7,3,5,10])    # return    0
</code></pre><h4 id="resolution-1"><a href="#resolution-1" class="headerlink" title="resolution:"></a>resolution:</h4><pre><code>def num_greater(threshold, values):
if len(values)==0:
   return 0
if values[0]&lt;= (threshold):
   return num_greater(threshold, values[1:])
else:
    return 1+ num_greater(threshold, values[1:])

if __name__==&quot;__main__&quot;:
    print(num_greater(5,[1,7,3,5,10]))
    print(num_greater(10,[1,7,3,5,10]))
</code></pre><h3 id="index-last"><a href="#index-last" class="headerlink" title="index_last()"></a>index_last()</h3><h4 id="question-2"><a href="#question-2" class="headerlink" title="question:"></a>question:</h4><p>4.1)write a function index_last(c, s) that takes as inputs a character c and a string s and that uses recursion to find and return the index of the last occurrence of c(if any) in the string s.If the character c is not found in s,please return -1. For example:</p>
<pre><code>index_last(&apos;a&apos;,&apos;banana&apos;)        # return    5
index_last(&apos;x&apos;,&apos;hello&apos;)         # return    -1
</code></pre><h4 id="resolution-2"><a href="#resolution-2" class="headerlink" title="resolution:"></a>resolution:</h4><pre><code>def index_last(c,s):
if(len(s)==0):
    return -1
elif(c==s[-1]):
    return len(s)-1
else:
    return index_last(c,s[:-1])

if __name__==&quot;__main__&quot;:
    print( index_last(&apos;a&apos;,&apos;banana&apos;))
    print( index_last(&apos;x&apos;,&apos;hello&apos;))
</code></pre><h3 id="lcs"><a href="#lcs" class="headerlink" title="lcs()"></a>lcs()</h3><h4 id="question-3"><a href="#question-3" class="headerlink" title="question:"></a>question:</h4><p>4.3)write a function lcs(s1, s2) that takes two strings s2 and s2 and uses recursion to return the longest common subsequence(LCS) that they share.The LCS is a string whose letters appear in both s1 and s2; these letters must appear in the same order in both s1 and s2,but not necessarily comsecutively. For example:</p>
<pre><code>lcs(&apos;human&apos;, &apos;chimp&apos;)           # return    &apos;hm&apos;
lcs(&apos;abcdefg&apos;,&apos;efghabcd&apos;)       # return    &apos;abcd&apos; (&apos;efgh&apos; would also be fine)
</code></pre><h4 id="resolution-3"><a href="#resolution-3" class="headerlink" title="resolution:"></a>resolution:</h4><pre><code>def lcs(s1,s2):
if(len(s1)==0 or len(s2)==0):
    return &apos;&apos;
elif(s1[0]==s2[0]):
    return s1[0]+lcs(s1[1:],s2[1:])
else:
    result1 = lcs(s1[1:],s2)
    result2 = lcs(s1,s2[1:])
    if (len(result1)&gt;len(result2)):
        return result1
    else:
        return result2

if __name__==&quot;__main__&quot;:
    print( lcs(&apos;human&apos;, &apos;chimp&apos;))
    print( lcs(&apos;gattaca&apos;,&apos;tacgaata&apos;))
    print( lcs(&apos;&apos;,&apos;whew&apos;))
    print( lcs(&apos;abcdefg&apos;,&apos;efghabcd&apos;))
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tkinter实践]]></title>
      <url>http://yoursite.com/2015/10/07/Tkinter%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><ul>
<li>电脑系统：windows10 64bit</li>
<li>python版本： 3.5.2 64bit</li>
<li>IDE： PyCharm Community Edition 2016.2.2</li>
</ul>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><ul>
<li>单词自考自查工具</li>
<li>读取xlsx格式的词典，可进行中译英，英译中的顺序或随机自查，对结果可保存为txt格式的文本</li>
<li>自动记录中-&gt;英错误次数，以日志形式保存</li>
<li>具体见程序的版本信息部分</li>
</ul>
<h2 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h2><ul>
<li>tkinter</li>
<li>os</li>
<li>xlrd</li>
<li>xlwt</li>
<li>xlutils</li>
<li>random</li>
<li>pyinstaller</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/chenxiaoyu2016/tkinter_dict/blob/master/tkinter_dict.py" target="_blank" rel="external">完整python源码</a></p>
<h2 id="可执行文件（-exe）"><a href="#可执行文件（-exe）" class="headerlink" title="可执行文件（.exe）"></a>可执行文件（.exe）</h2><p><a href="https://github.com/chenxiaoyu2016/tkinter_dict/tree/master/build_version4" target="_blank" rel="external">windows下可执行文件</a></p>
<h2 id="部分细节说明"><a href="#部分细节说明" class="headerlink" title="部分细节说明"></a>部分细节说明</h2><h3 id="自定义窗体返回按钮功能"><a href="#自定义窗体返回按钮功能" class="headerlink" title="自定义窗体返回按钮功能"></a>自定义窗体返回按钮功能</h3><pre><code>root=Tk()
root.geometry(&quot;800x500&quot;)
root.protocol(&quot;WM_DELETE_WINDOW&quot;, callback)
</code></pre><p> callback函数功能可自定义，调用root的destroy方法可关闭窗体。</p>
<h3 id="使光标默认聚焦在某一控件"><a href="#使光标默认聚焦在某一控件" class="headerlink" title="使光标默认聚焦在某一控件"></a>使光标默认聚焦在某一控件</h3><pre><code># create Entry module
e = StringVar()
entry = Entry(root, validate=&apos;key&apos;, textvariable=e, width=20,font=(&quot;宋体&quot;, 18, &quot;bold&quot;))
entry.pack()
entry.bind(&apos;&lt;Return&gt;&apos;, rtnkey)
entry.focus_force()
</code></pre><p>很多控件都有focus_force方法，该方法即会将光标默认设在对应控件上。</p>
<h3 id="使滚动条自动滚动到最底部"><a href="#使滚动条自动滚动到最底部" class="headerlink" title="使滚动条自动滚动到最底部"></a>使滚动条自动滚动到最底部</h3><pre><code># create text module
textPad=Text(root,undo=True)
textPad.pack(expand=YES,fill=BOTH)

#create scroll bar
scroll=Scrollbar(textPad)
textPad.config(yscrollcommand=scroll.set)
scroll.config(command=textPad.yview)
scroll.config(cursor=&apos;hand2&apos;)
scroll.pack(side=RIGHT,fill=Y)

textPad.insert(CURRENT,&apos;\n&apos;)
textPad.see(END)
</code></pre><p>关键在最后两行，text组件的插入使用insert方法，示例中在当前位置CURRENT插入了一个换行符，see方法（参数为END）可使text组件处在可见内容的最尾部，即可使滚动条默认处在最底部。<br>如果滚动条没有处在最底部就调用text组件的insert方法，会在界面显示可见的最后一行插入，而不是text组件整体的CURRENT位置插入。</p>
<h3 id="xls-xlsx文件的读-写-改写"><a href="#xls-xlsx文件的读-写-改写" class="headerlink" title="xls/xlsx文件的读/写/改写"></a>xls/xlsx文件的读/写/改写</h3><pre><code># read a xls/xlsx file
import xlrd
file = &apos;C:/Users/chenxy/Desktop/tkinter_dict/test_data.xlsx&apos;
raw_data = xlrd.open_workbook(file)
table = raw_data.sheets()[0]
col0 = table.col_values(0)
row0 = table.row_values(0)
</code></pre><p>xlrd的文件读取，对于xls，xlsx都没问题。</p>
<pre><code>#write a new xls file 
import xlwt
file = xlwt.Workbook()
table = file.add_sheet(&apos;sheet1&apos;, cell_overwrite_ok=True)
table.write(0, 0, &apos;[0,0]&apos;)
for i in range(0, 10):
    table.write(0 , i, &apos;[0,&apos;+str(i)+&apos;]&apos;)
file.save(&apos;C:/Users/chenxy/Desktop/tkinter_dict/new_data.xls&apos;)
</code></pre><p>cell_overwrite_ok=True可以使文件在保存之前重写，<br>xlwt只能生成xls文件；生成xlsx文件也不会报错，但无法打开，显示已损坏。可能跟python版本有关，换成低版本也许能表现正常。</p>
<pre><code>#rewrite a xls file existed
import xlutils
file = &apos;C:/Users/chenxy/Desktop/tkinter_dict/test_data.xlsx&apos;
raw_data = xlrd.open_workbook(file)
file_copy = xlutils.copy.copy(raw_data)
table = file_copy.get_sheet(0)
for i in range(0, 10):
    table.write(0 , i, &apos;[0,&apos;+str(i)+&apos;]&apos;)
file_copy.save(&apos;C:/Users/chenxy/Desktop/tkinter_dict/test_data.xlsx&apos;)
</code></pre><p>使用xlutils的copy方法，之后的部分按照xlrd的相似方式写即可。<br>注：xlutils是基于xlrd和xlwt的。</p>
<h3 id="python代码打包成exe文件"><a href="#python代码打包成exe文件" class="headerlink" title="python代码打包成exe文件"></a>python代码打包成exe文件</h3><p> python有很多用于打包的模块，但对于python3.5，目前能正常使用的貌似只有pyinstaller（并且对于32位，64位都支持）。在cmd中，进入到python文件所在目录，然后执行如下代码：</p>
<pre><code>pyinstaller -F -w 文件名.py
</code></pre><p>-F 表示生成单个可执行文件，即将所有依赖文件都集中到一个exe文件中<br>-w 表示去掉控制台窗口，这在GUI界面时非常有用。不过如果是命令行程序的话那要把这个选项删除</p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>http://yoursite.com/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[about]]></title>
      <url>http://yoursite.com/about/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[categories]]></title>
      <url>http://yoursite.com/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
